//#define _CRT_SECURE_NO_WARNINGS 1;
//#include<stdio.h>
//#include<malloc.h>
//#define N 1000
///*
//输入 4,3
//1 2 3 4 
//最底层嵌套 1
//1 嵌套 2
//2 嵌套 3
//3 嵌套 4 只有一个的时候跳出该层嵌套
//2 嵌套 4 跳出
//1 嵌套 3 重复
//具体的来说：
//1.为了求得问题的解，先选择某一种可能情况向前探索；
//2.在探索过程中，一旦发现原来的选择是错误的，就退回一步重新选择，继续向前探索；
//3.如此反复进行，直至得到解或证明无解。
//枚举的循环转换为recursion
//*/
//int n, r;
//int a[510] = {0};
//int book[510] = {false};// 标记是否被访问
//int ans = 0;//记录符合条件的次数
////对n进行全排列
//void dfs(int cur)
//{
//	if (cur == r){
//		for (int i = 0; i < cur; ++i)
//			printf("%d ", a[i]);//控制每次打印出k个数字组成的组合
//		printf("\n");
//		return;//返回上一级的dfs函数
//	}
//	for (int i = 0; i < n; ++i) {
//		if (!book[i])/*如果没有被访问*/{
//			book[i] = 1;//标记为已经被访问
//			a[cur] = i+1;//每次调用dfs arr中的值得到更新
//			dfs(cur + 1);
//			book[i] = 0;
//		}
//	}
//	return;//同样是返回上一级dfs函数
//}
////1-9 9个数凑一个等式，其中每个数由3个数字组成
////从9个中选出3个,再从剩下的6个中选出3个,再从最后的3个中选
//int main()
//{
//	scanf("%d %d", &n,&r);
//	dfs(0);
//	return 0;
//}